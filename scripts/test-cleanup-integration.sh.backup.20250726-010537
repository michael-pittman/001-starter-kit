#!/bin/bash
# =============================================================================
# Cleanup Integration Test Script
# Tests that all deployment scripts properly integrate with cleanup-unified.sh
# =============================================================================

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

log() { echo -e "${BLUE}[$(date +'%Y-%m-%d %H:%M:%S')] $1${NC}" >&2; }
error() { echo -e "${RED}❌ [ERROR] $1${NC}" >&2; }
success() { echo -e "${GREEN}✅ [SUCCESS] $1${NC}" >&2; }
warning() { echo -e "${YELLOW}⚠️  [WARNING] $1${NC}" >&2; }
info() { echo -e "${CYAN}ℹ️  [INFO] $1${NC}" >&2; }
step() { echo -e "${PURPLE}🔸 [STEP] $1${NC}" >&2; }

# Test counters
TESTS_PASSED=0
TESTS_FAILED=0
TESTS_SKIPPED=0

increment_test_counter() {
    local result="$1"
    case $result in
        "pass") ((TESTS_PASSED++)) ;;
        "fail") ((TESTS_FAILED++)) ;;
        "skip") ((TESTS_SKIPPED++)) ;;
    esac
}

print_test_summary() {
    echo "=============================================="
    echo "📊 CLEANUP INTEGRATION TEST SUMMARY"
    echo "=============================================="
    echo "✅ Tests Passed: $TESTS_PASSED"
    echo "❌ Tests Failed: $TESTS_FAILED"
    echo "⏭️  Tests Skipped: $TESTS_SKIPPED"
    echo "📈 Total Tests: $((TESTS_PASSED + TESTS_FAILED + TESTS_SKIPPED))"
    echo ""
    
    if [ $TESTS_FAILED -eq 0 ]; then
        success "All cleanup integration tests passed!"
        return 0
    else
        error "$TESTS_FAILED test(s) failed"
        return 1
    fi
}

test_cleanup_script_exists() {
    step "Testing cleanup-unified.sh script exists"
    
    if [ -f "$SCRIPT_DIR/cleanup-unified.sh" ]; then
        success "cleanup-unified.sh script found"
        increment_test_counter "pass"
    else
        error "cleanup-unified.sh script not found"
        increment_test_counter "fail"
        return 1
    fi
}

test_cleanup_script_executable() {
    step "Testing cleanup-unified.sh script is executable"
    
    if [ -x "$SCRIPT_DIR/cleanup-unified.sh" ]; then
        success "cleanup-unified.sh script is executable"
        increment_test_counter "pass"
    else
        warning "cleanup-unified.sh script is not executable, making it executable"
        chmod +x "$SCRIPT_DIR/cleanup-unified.sh"
        if [ -x "$SCRIPT_DIR/cleanup-unified.sh" ]; then
            success "Made cleanup-unified.sh script executable"
            increment_test_counter "pass"
        else
            error "Failed to make cleanup-unified.sh script executable"
            increment_test_counter "fail"
            return 1
        fi
    fi
}

test_cleanup_script_help() {
    step "Testing cleanup-unified.sh help functionality"
    
    if "$SCRIPT_DIR/cleanup-unified.sh" --help >/dev/null 2>&1; then
        success "cleanup-unified.sh help command works"
        increment_test_counter "pass"
    else
        error "cleanup-unified.sh help command failed"
        increment_test_counter "fail"
        return 1
    fi
}

test_deployment_script_cleanup_integration() {
    local script_name="$1"
    local script_path="$SCRIPT_DIR/$script_name"
    
    step "Testing cleanup integration in $script_name"
    
    if [ ! -f "$script_path" ]; then
        warning "Script $script_name not found, skipping"
        increment_test_counter "skip"
        return 0
    fi
    
    # Check if script contains the improved cleanup logic
    if grep -q "cleanup-unified.sh" "$script_path" && \
       grep -q "run_manual_cleanup" "$script_path"; then
        success "Script $script_name has proper cleanup integration"
        increment_test_counter "pass"
    else
        error "Script $script_name missing proper cleanup integration"
        increment_test_counter "fail"
        return 1
    fi
}

test_cleanup_function_definition() {
    local script_name="$1"
    local script_path="$SCRIPT_DIR/$script_name"
    
    step "Testing cleanup function definition in $script_name"
    
    if [ ! -f "$script_path" ]; then
        warning "Script $script_name not found, skipping"
        increment_test_counter "skip"
        return 0
    fi
    
    # Check if script contains the run_manual_cleanup function
    if grep -q "run_manual_cleanup()" "$script_path"; then
        success "Script $script_name has run_manual_cleanup function"
        increment_test_counter "pass"
    else
        error "Script $script_name missing run_manual_cleanup function"
        increment_test_counter "fail"
        return 1
    fi
}

test_cleanup_on_failure_logic() {
    local script_name="$1"
    local script_path="$SCRIPT_DIR/$script_name"
    
    step "Testing cleanup_on_failure logic in $script_name"
    
    if [ ! -f "$script_path" ]; then
        warning "Script $script_name not found, skipping"
        increment_test_counter "skip"
        return 0
    fi
    
    # Check if script has proper cleanup_on_failure logic
    if grep -q "cleanup_on_failure()" "$script_path" && \
       grep -q "cleanup-unified.sh.*--force" "$script_path"; then
        success "Script $script_name has proper cleanup_on_failure logic"
        increment_test_counter "pass"
    else
        error "Script $script_name missing proper cleanup_on_failure logic"
        increment_test_counter "fail"
        return 1
    fi
}

test_manual_cleanup_completeness() {
    local script_name="$1"
    local script_path="$SCRIPT_DIR/$script_name"
    
    step "Testing manual cleanup completeness in $script_name"
    
    if [ ! -f "$script_path" ]; then
        warning "Script $script_name not found, skipping"
        increment_test_counter "skip"
        return 0
    fi
    
    # Check for key cleanup operations
    local required_operations=(
        "terminate-instances"
        "delete-security-group"
        "delete-instance-profile"
        "delete-role"
    )
    
    local missing_operations=0
    for operation in "${required_operations[@]}"; do
        if ! grep -q "$operation" "$script_path"; then
            warning "Script $script_name missing operation: $operation"
            ((missing_operations++))
        fi
    done
    
    if [ $missing_operations -eq 0 ]; then
        success "Script $script_name has complete manual cleanup operations"
        increment_test_counter "pass"
    else
        error "Script $script_name missing $missing_operations cleanup operations"
        increment_test_counter "fail"
        return 1
    fi
}

test_cleanup_script_dry_run() {
    step "Testing cleanup-unified.sh dry-run functionality"
    
    # Test with a non-existent stack name to avoid actual cleanup
    if echo "y" | "$SCRIPT_DIR/cleanup-unified.sh" --dry-run --verbose "test-stack-nonexistent" >/dev/null 2>&1; then
        success "cleanup-unified.sh dry-run works correctly"
        increment_test_counter "pass"
    else
        error "cleanup-unified.sh dry-run failed"
        increment_test_counter "fail"
        return 1
    fi
}

test_cleanup_script_force_flag() {
    step "Testing cleanup-unified.sh force flag functionality"
    
    # Test with a non-existent stack name to avoid actual cleanup
    if "$SCRIPT_DIR/cleanup-unified.sh" --force --dry-run "test-stack-nonexistent" >/dev/null 2>&1; then
        success "cleanup-unified.sh force flag works correctly"
        increment_test_counter "pass"
    else
        error "cleanup-unified.sh force flag failed"
        increment_test_counter "fail"
        return 1
    fi
}

test_cleanup_script_verbose_mode() {
    step "Testing cleanup-unified.sh verbose mode"
    
    # Test with a non-existent stack name to avoid actual cleanup
    local output
    output=$(echo "y" | "$SCRIPT_DIR/cleanup-unified.sh" --verbose --dry-run "test-stack-nonexistent" 2>&1)
    
    if echo "$output" | grep -q "CLEANUP SUMMARY" && \
       echo "$output" | grep -q "Resources processed"; then
        success "cleanup-unified.sh verbose mode provides detailed output"
        increment_test_counter "pass"
    else
        error "cleanup-unified.sh verbose mode not working properly"
        increment_test_counter "fail"
        return 1
    fi
}

test_deployment_scripts() {
    step "Testing all deployment scripts for cleanup integration"
    
    local deployment_scripts=(
        "aws-deployment.sh"
        "aws-deployment-unified.sh"
        "aws-deployment-simple.sh"
        "aws-deployment-ondemand.sh"
    )
    
    for script in "${deployment_scripts[@]}"; do
        test_deployment_script_cleanup_integration "$script"
        test_cleanup_function_definition "$script"
        test_cleanup_on_failure_logic "$script"
        test_manual_cleanup_completeness "$script"
    done
}

test_cleanup_script_features() {
    step "Testing cleanup-unified.sh advanced features"
    
    # Test different modes
    local modes=("stack" "efs" "all" "specific")
    for mode in "${modes[@]}"; do
        if echo "y" | "$SCRIPT_DIR/cleanup-unified.sh" --mode "$mode" --dry-run "test-stack" >/dev/null 2>&1; then
            success "cleanup-unified.sh mode '$mode' works"
            increment_test_counter "pass"
        else
            error "cleanup-unified.sh mode '$mode' failed"
            increment_test_counter "fail"
        fi
    done
    
    # Test resource type flags
    local resource_flags=("--instances" "--efs" "--iam" "--network" "--monitoring" "--storage")
    for flag in "${resource_flags[@]}"; do
        if echo "y" | "$SCRIPT_DIR/cleanup-unified.sh" --mode specific "$flag" --dry-run "test-stack" >/dev/null 2>&1; then
            success "cleanup-unified.sh flag '$flag' works"
            increment_test_counter "pass"
        else
            error "cleanup-unified.sh flag '$flag' failed"
            increment_test_counter "fail"
        fi
    done
}

test_error_handling() {
    step "Testing error handling in cleanup scripts"
    
    # Test with invalid arguments
    if ! "$SCRIPT_DIR/cleanup-unified.sh" --invalid-flag 2>/dev/null; then
        success "cleanup-unified.sh properly handles invalid arguments"
        increment_test_counter "pass"
    else
        error "cleanup-unified.sh doesn't handle invalid arguments properly"
        increment_test_counter "fail"
    fi
    
    # Test with missing stack name
    if ! "$SCRIPT_DIR/cleanup-unified.sh" 2>/dev/null; then
        success "cleanup-unified.sh properly handles missing stack name"
        increment_test_counter "pass"
    else
        error "cleanup-unified.sh doesn't handle missing stack name properly"
        increment_test_counter "fail"
    fi
}

main() {
    echo "=============================================="
    echo "🧪 CLEANUP INTEGRATION TEST SUITE"
    echo "=============================================="
    echo ""
    
    # Test cleanup script basics
    test_cleanup_script_exists
    test_cleanup_script_executable
    test_cleanup_script_help
    
    # Test cleanup script functionality
    test_cleanup_script_dry_run
    test_cleanup_script_force_flag
    test_cleanup_script_verbose_mode
    test_cleanup_script_features
    
    # Test error handling
    test_error_handling
    
    # Test deployment script integration
    test_deployment_scripts
    
    # Print summary
    echo ""
    print_test_summary
}

# Run main function
main "$@" 